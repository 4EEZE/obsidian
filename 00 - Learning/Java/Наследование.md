*Наследование* - это когда подкласс может наследовать свойства и методы родительского класса.

Пример:
У нас есть главный класс "Enemy", в котором есть такие свойства как агрессивность по отношению к игроку и горение на солнце. Далее у нас есть подкласс "Zombie", который очевидно являеться врагом, а значит должен наследовать от "Enemy" все его свойства. Но так же мы можем прописать для "Zombie" свои уникальные свойства по типу увеличенный радиус видимости. И если мы добавим какуето разновидность зомби, допустим "Zombie_runner", то он наследует все свойства одновременно и от Enemy, и от Zombie, но мы так же можем сделать новый вид Runner'а и так до бесконечности можно.

```java
// Базовый класс для всех врагов
public class Enemy {
    protected boolean isAggressive; // Агрессивность
    protected boolean burnsInSunlight; // Горение на солнце

    public Enemy() {
        this.isAggressive = true; // По умолчанию агрессивны
        this.burnsInSunlight = false; // По умолчанию не горят
    }

    public void attack() {
        System.out.println("Враг атакует!");
    }
}

// Подкласс Zombie наследует Enemy
public class Zombie extends Enemy {
    protected int visionRadius; // Уникальное свойство: радиус видимости

    public Zombie() {
        super(); // Вызов конструктора родителя (Enemy)
        this.visionRadius = 10; // Стандартный радиус для зомби
        this.burnsInSunlight = true; // Переопределили свойство родителя
    }

    public void groan() {
        System.out.println("Зомби стонет: Уууу...");
    }
}

// Подкласс ZombieRunner наследует Zombie
public class ZombieRunner extends Zombie {
    private int speed; // Уникальное свойство: скорость

    public ZombieRunner() {
        super(); // Вызов конструктора Zombie
        this.speed = 20; 
        this.visionRadius = 15; // Увеличили радиус видимости для бегуна
    }

    public void sprint() {
        System.out.println("Зомби-бегун мчится со скоростью " + speed + " км/ч!");
    }
}
```

Линки:
[[ООП]]
[[Полиморфизм]]
[[Java]]